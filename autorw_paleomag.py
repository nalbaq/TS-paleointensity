# -*- coding: utf-8 -*-
"""AutoRW_paleoMag.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-NOagYJbqX5HztSjOD7LHkKJ6HoL--uY
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from scipy.interpolate import CubicSpline, UnivariateSpline
from datetime import datetime

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
from google.colab import drive
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from datetime import datetime

from scipy.interpolate import CubicSpline

import warnings
warnings.filterwarnings('ignore')


# Función para crear directorios si no existen
def create_directory(directory_path):
    if not os.path.exists(directory_path):
        os.makedirs(directory_path)
        print(f"Directorio creado: {directory_path}")


# 0. Load data VADM
drive.mount('/content/drive/',force_remount=True)
pint = pd.read_excel('/content/drive/MyDrive/Colab Notebooks/PINTv811.xlsx')

results_base_dir = '/content/drive/MyDrive/VADM_Results'
create_directory(results_base_dir)

filtro_edad = 5
pint_10my = pint[pint['AGE'] <= filtro_edad]
columns_vadm = ['AGE', 'VADM', 'VDM', 'VDM/VADM']
data_vadm = pint_10my[columns_vadm]
data_vadm.sort_values(by='AGE', ascending=True, inplace=True)

# Treatment for null data at VADM, VDM, VDM/VADM
data_vadm.loc[data_vadm['VADM'].isnull() & data_vadm['VDM'].notnull(), 'VADM'] = data_vadm['VDM']
data_vadm.loc[data_vadm['VADM'].isnull() & data_vadm['VDM'].isnull() & data_vadm['VDM/VADM'].notnull(), 'VADM'] = data_vadm['VDM/VADM']
columns= ['AGE', 'VADM']
data_vadm = data_vadm[columns]

# Subchrones de polaridad magnética
subchrones = {
    "C1n (Brunhes)": {"techo": 0.000, "base": 0.773},
    "C1r.1r (Matuyama)": {"techo": 0.773, "base": 0.990},
    "C1r.1n (Jaramillo)": {"techo": 0.990, "base": 1.070},
    "C1r.2r": {"techo": 1.070, "base": 1.180},
    "C1r.2n (Cobb Mountain)": {"techo": 1.180, "base": 1.215},
    "C1r.3r": {"techo": 1.215, "base": 1.775},

    "C2n (Olduvai)": {"techo": 1.775, "base": 1.934},

    "C2r.1r": {"techo": 1.934, "base": 2.116},
    "C2r.1n (Feni)": {"techo": 2.116, "base": 2.140},
    "C2r.2r (Matuyama)": {"techo": 2.140, "base": 2.595},
    "C2An.1n (Gauss)": {"techo": 2.595, "base": 3.032},
    "C2An.1r (Keana)": {"techo": 3.032, "base": 3.116},
    "C2An.2n": {"techo": 3.116, "base": 3.207},
    "C2An.2r (Mammoth)": {"techo": 3.207, "base": 3.330},
    "C2An.3n (Gauss)": {"techo": 3.330, "base": 3.596},
    "C2Ar (Gilbert)": {"techo": 3.596, "base": 4.187},

    "C3n.1n (Cochiti)": {"techo": 4.187, "base": 4.300},
    "C3n.1r": {"techo": 4.300, "base": 4.631},
    "C3n.2n (Nunivak)": {"techo": 4.631, "base": 4.799},
    "C3n.2r": {"techo": 4.799, "base": 4.896},
    "C3n.3n (Sidufjall)": {"techo": 4.896, "base": 4.997}
}

def impute_paleointensity(data_vadm, window_step, age_column='AGE', vadm_column='VADM', time_range=5.01):
    """
    Imputes missing paleointensity data (VADM) in a geological timescale.

    Args:
        data_vadm (pandas.DataFrame): DataFrame containing the paleointensity data.  *NO LONGER CSV PATH*
        window_step (float): The window step size in million years (Myr).
        age_column (str): Name of the column containing the age data. Defaults to 'AGE'.
        vadm_column (str): Name of the column containing the VADM data. Defaults to 'VADM'.
        time_range (float): Time range to consider for imputation (in Myr).  Defaults to 5.01.

    Returns:
        pandas.DataFrame: The DataFrame with the 'window', 'mean_VADM', and 'std_VADM' columns added.
                           Returns None if there are errors processing the data.
    """

    # 1. Create the 'window' column
    sequence = np.arange(0, time_range, window_step)
    new_column = pd.Series(np.nan, index=data_vadm.index)
    assignment_limit = min(len(sequence), len(new_column))
    new_column[:assignment_limit] = sequence[:assignment_limit]

    data_vadm['window'] = new_column

    # 2. Calculate mean VADM for each window
    def calculate_mean_vadm(ventana, df, age_column, vadm_column):
        filtered_df = df[(df[age_column] >= 0.00) & (df[age_column] < ventana)]
        if filtered_df.empty:
            return np.nan
        else:
            return filtered_df[vadm_column].mean() # Use filtered_df here!

    data_vadm['mean_VADM'] = data_vadm['window'].apply(lambda x: calculate_mean_vadm(x, data_vadm, age_column, vadm_column))

    # Refine mean_VADM calculation within each window
    unique_ventana_values = sorted(data_vadm['window'].unique())
    for i, ventana_value in enumerate(unique_ventana_values):
        if ventana_value > time_range:
            data_vadm.loc[data_vadm['window'] == ventana_value, 'mean_VADM'] = np.nan
        else:
            lower_limit = 0 if i == 0 else unique_ventana_values[i - 1]
            data_vadm.loc[data_vadm['window'] == ventana_value, 'mean_VADM'] = data_vadm[
                (data_vadm[age_column] >= lower_limit) &
                (data_vadm[age_column] <= ventana_value)
            ][vadm_column].mean()

    # 3. Calculate standard deviation of VADM for each window
    def calculate_std_vadm(ventana, df, age_column, vadm_column):
        filtered_df = df[(df[age_column] >= 0) & (df[age_column] < ventana)] # use filtered_df
        if filtered_df.empty or len(filtered_df) <= 1: # Require at least two points for std
            return np.nan
        else:
            return filtered_df[vadm_column].std(ddof=0) #use filtered_df

    data_vadm['std_VADM'] = data_vadm['window'].apply(lambda x: calculate_std_vadm(x, data_vadm, age_column, vadm_column))

    # Refine std_VADM calculation within each window
    unique_ventana_values = sorted(data_vadm['window'].unique())
    for i, ventana_value in enumerate(unique_ventana_values):
        if ventana_value > time_range:
            data_vadm.loc[data_vadm['window'] == ventana_value, 'std_VADM'] = np.nan
        else:
            lower_limit = 0 if i == 0 else unique_ventana_values[i - 1]
            data_vadm.loc[data_vadm['window'] == ventana_value, 'std_VADM'] = data_vadm[
                (data_vadm[age_column] >= lower_limit) &
                (data_vadm[age_column] <= ventana_value)
            ][vadm_column].std(ddof=0)
    return data_vadm


# 4. Plot mean VADM on rolling window with bar errors

def plot_vadm(df, window_step, ax,  age_column='window', vadm_mean_column='mean_VADM',
              vadm_std_column='std_VADM', time_range=5.01, label_suffix=""):
    """
    Plots the mean VADM with error bars representing the standard deviation on a given axis.

    Args:
        df (pandas.DataFrame): DataFrame containing the 'window', 'mean_VADM', and 'std_VADM' columns.
        window_step (float): Window step size (for x-axis error bars).
        ax (matplotlib.axes._axes.Axes):  The axis object to plot on.
        age_column (str): Name of the age column ('window' in this case).
        vadm_mean_column (str): Name of the mean VADM column.
        vadm_std_column (str): Name of the standard deviation VADM column.
        time_range (float): Time range to consider for imputation (in Myr).  Defaults to 5.01.
        label_suffix (str):  Suffix to add to the label for the legend
    """

    df_plot = df.dropna(subset=[vadm_mean_column])
    if df_plot.empty:
        print("Warning: No data to plot after dropping NaN values in 'mean_VADM'. Check your data or window size.")
        return

    #ax.scatter(df_plot[age_column], df_plot[vadm_mean_column], label='PINT', facecolors='none', edgecolors='black', s=8,linewidth=0.4)
    ax.plot(df_plot[age_column], df_plot[vadm_mean_column],  linestyle='-', linewidth=0.7, label=f'Mean VADM{label_suffix}')
    #ax.errorbar(df_plot[age_column], df_plot[vadm_mean_column], yerr=df_plot[vadm_std_column], fmt='none', ecolor='gray', elinewidth=0.3, capsize=3, label = f'Standard Deviation{label_suffix}')
    #ax.errorbar(df_plot[age_column], df_plot[vadm_mean_column], xerr=window_step, fmt='none', ecolor='gray', elinewidth=0.3, capsize=3, label = f'Window Step{label_suffix}')
    #ax.fill_between(df_plot[age_column], df_plot[vadm_mean_column] - df_plot[vadm_std_column], df_plot[vadm_mean_column] + df_plot[vadm_std_column], alpha=0.3, label=f'RW ± σ{label_suffix}')

    # Optionally, remove duplicate labels from the legend (more complex if you need *all* labels)

    ax.grid(True, linestyle='--', linewidth=0.2)
    ax.set_xlim(0, 5)


# 5. Calculate metrics of imputed data
def calculate_fit_metric(df, age_column='window', vadm_mean_column='mean_VADM', vadm_column='VADM'):
  """
  Calculates a simple Mean Absolute Error (MAE) metric to assess the fit of the imputed data.
  This compares the imputed mean VADM values to the original VADM values within each window.
  This is a basic example and can be replaced with a more sophisticated metric.
  """
  df_valid = df.dropna(subset=[vadm_mean_column, vadm_column])

  if df_valid.empty:
      print("Warning: No overlapping data points to calculate fit metric.")
      return np.inf

  mae = np.mean(np.abs(df_valid[vadm_column] - df_valid[vadm_mean_column]))
  return mae


def calculate_rmse(df, age_column='window', vadm_mean_column='mean_VADM', vadm_column='VADM'):
  df_valid = df.dropna(subset=[vadm_mean_column, vadm_column])
  if df_valid.empty:
      print("Warning: No overlapping data points to calculate RMSE.")
      return np.inf

  mse = mean_squared_error(df_valid[vadm_column], df_valid[vadm_mean_column])
  rmse = np.sqrt(mse)
  return rmse

def calculate_r_squared(df, age_column='window', vadm_mean_column='mean_VADM', vadm_column='VADM'):
  df_valid = df.dropna(subset=[vadm_mean_column, vadm_column])
  if df_valid.empty:
      print("Warning: No overlapping data points to calculate R-squared.")
      return np.nan

  r2 = r2_score(df_valid[vadm_column], df_valid[vadm_mean_column])
  return r2

def calculate_mape(df, age_column='window', vadm_mean_column='mean_VADM', vadm_column='VADM'):
  df_valid = df.dropna(subset=[vadm_mean_column, vadm_column])
  if df_valid.empty:
      print("Warning: No overlapping data points to calculate MAPE.")
      return np.inf

  actual = df_valid[vadm_column].values
  predicted = df_valid[vadm_mean_column].values

  actual = np.where(actual == 0, 1e-8, actual)

  mape = np.mean(np.abs((actual - predicted) / actual)) * 100
  return mape

if __name__ == "__main__":
    # Input window steps  (Prompt the user)
    window_steps_str = input("Enter window steps (comma separated, e.g., 0.005,0.01,0.05): ")
    try:
        window_steps = [float(x) for x in window_steps_str.split(',')]
    except ValueError:
        print("Invalid input.  Using default window steps: 0.005, 0.01, 0.05")
        window_steps = [0.005, 0.01, 0.05]


    # Crear directorio con fecha para esta ejecución
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    run_dir = os.path.join(results_base_dir, f"run_{timestamp}")
    create_directory(run_dir)

    # Archivo para guardar métricas de todas las ejecuciones
    metrics_file = os.path.join(run_dir, "metrics_summary.csv")
    metrics_data = []

    # Create the figure and axes OUTSIDE the loop
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(20, 7), gridspec_kw={'height_ratios': [4, 1]}, sharex=True)
    ax1.set_title(f"Mean VADM for last 5 My", fontsize=15, pad=20)  # Generic Title
    ax1.set_ylabel('VADM (x10^22 Am²)', fontsize=12)
    ax1.set_xticks(np.arange(0, 5.01, 0.5))

    colores = ["black", "white"] * (len(subchrones) // 2 + 1)

    for i, (subcron, datos) in enumerate(subchrones.items()):
        ax2.barh(0, width=datos["techo"] - datos["base"], left=datos["base"], height=0.6, color=colores[i], edgecolor="black")

    ax2.yaxis.set_visible(False)
    ax2.set_xlabel('Age (Myr)', fontsize=12)

    for spine in ax2.spines.values():
        spine.set_visible(False)

    for subcron, datos in subchrones.items():
        ax2.text((datos["base"] + datos["techo"]) / 2, 0, subcron, ha="center", va="center", color="white" if colores[list(subchrones.keys()).index(subcron)] == "black" else "black", fontsize=7, rotation=90)

    ax2.set_xlim(0, 5)
    plt.subplots_adjust(hspace=0)

    # Procesar cada window_step
    for window_step_index, window_step in enumerate(window_steps):
        window_step_doubled = window_step * 2
        print(f"Processing with window_step = {window_step_doubled}")

        # Crear directorio específico para este window_step
        window_dir = os.path.join(run_dir, f"window_step_{window_step_doubled}")
        create_directory(window_dir)

        # Impute data
        data_imputed = impute_paleointensity(data_vadm.copy(), window_step)

        if data_imputed is not None:
            # Guardar datos imputados como .xls
            excel_filename = f"imputed_data_window_{window_step_doubled}.xlsx" # Use XLSX
            excel_path = os.path.join(window_dir, excel_filename)
            data_imputed.to_excel(excel_path, index=False, engine='openpyxl')
            print(f"Imputed data saved to: {excel_path}")

            # Generar and add plot to the existing figure
            label_suffix = f" ({window_step_doubled})" # Add info to the legend
            plot_vadm(data_imputed, window_step, ax1, label_suffix=label_suffix)  # Plot to ax1

            # Calculate metrics
            mae = calculate_fit_metric(data_imputed)
            rmse = calculate_rmse(data_imputed)
            r2 = calculate_r_squared(data_imputed)
            mape = calculate_mape(data_imputed)

            print(f"Window Step: {window_step_doubled}, MAE: {mae}, RMSE: {rmse}, R-squared: {r2}, MAPE: {mape}")

            # Guardar métricas en un archivo específico para este window_step
            metrics_window_file = os.path.join(window_dir, f"metrics_window_{window_step_doubled}.txt")
            with open(metrics_window_file, 'w') as f:
                f.write(f"Window Step: {window_step_doubled}\n")
                f.write(f"MAE: {mae}\n")
                f.write(f"RMSE: {rmse}\n")
                f.write(f"R-squared: {r2}\n")
                f.write(f"MAPE: {mape}\n")

            # Agregar resultados al resumen
            metrics_data.append({
                'window_step': window_step_doubled,
                'MAE': mae,
                'RMSE': rmse,
                'R_squared': r2,
                'MAPE': mape
            })
        else:
            print(f"Imputation failed for window_step = {window_step_doubled}")

    # Add legend AFTER plotting all window steps
    ax1.legend(loc='upper right', fontsize=10)

    # Save the combined plot
    plot_filename = "combined_VADM_plots.png"
    full_path = os.path.join(run_dir, plot_filename)
    plt.savefig(full_path, dpi=300)
    print(f"Combined plot saved to: {full_path}")
    plt.show()  # Show the plot in Colab

    # Guardar resumen de métricas
    if metrics_data:
        metrics_df = pd.DataFrame(metrics_data)
        metrics_df.to_csv(metrics_file, index=False)
        print(f"Metrics summary saved to: {metrics_file}")











